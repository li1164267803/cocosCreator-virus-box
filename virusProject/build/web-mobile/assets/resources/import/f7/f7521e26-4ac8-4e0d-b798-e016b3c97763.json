{"__type__":"cc.EffectAsset","_name":"PageTurn","techniques":[{"passes":[{"blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"targetTex":{"value":"white","type":29},"time":{"value":[0],"type":13}},"program":"PageTurn|vs|fs"}]}],"shaders":[{"hash":3615997285,"glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform sampler2D targetTex;\nuniform properties {\n  float time;\n};\nconst float MIN_AMOUNT = -0.16;\nconst float MAX_AMOUNT = 1.3;\nconst float PI = 3.141592653589793;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nconst float cylinderRadius = 1.0 / PI / 2.0;\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\nvec4 antiAlias(vec4 color1, vec4 color2, float distance) {\n    distance *= scale;\n    if (distance < 0.0) return color2;\n    if (distance > 2.0) return color1;\n    float dd = pow(1.0 - distance / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\nfloat distanceToEdge(vec3 point) {\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\nvec4 seeThrough(float cylinderAngle, float yc, vec2 p, mat3 rotation, mat3 rrotation) {\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {\n        return texture2D(targetTex, v_uv0);\n    }\n    if (yc > 0.0) return texture2D(texture, p);\n    vec4 color = texture2D(texture, point.xy);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\nvec4 seeThroughWithShadow(float amount, float cylinderAngle, float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation) {\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0) shadow = 0.0;\n    else shadow *= amount;\n    vec4 shadowColor = seeThrough(cylinderAngle, yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\nvec4 backside(float yc, vec3 point) {\n    vec4 color = texture2D(texture, point.xy);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\nvec4 behindSurface(float amount, float cylinderAngle, float yc, vec3 point, mat3 rrotation) {\n    float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\n    shado *= 1.0 - abs(point.x - 0.5);\n    yc = (-cylinderRadius - cylinderRadius - yc);\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n    point = hitPoint(hitAngle, yc, point, rrotation);\n    if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)){\n        shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n    } else\n        shado = 0.0;\n    return vec4(texture2D(targetTex, v_uv0).rgb - shado, 0.0);\n}\nvoid main(void) {\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.12, 0.258, 1\n    );\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.15, -0.5, 1\n    );\n    vec3 point = rotation * vec3(v_uv0, 1.0);\n    float amount = time * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\n    float cylinderAngle = 2.0 * PI * amount;\n    float yc = point.y - amount;\n    if (yc < -cylinderRadius) {\n        gl_FragColor = behindSurface(amount, cylinderAngle, yc, point, rrotation);\n        return;\n    }\n    if (yc > cylinderRadius) {\n        gl_FragColor = texture2D(texture, v_uv0);\n        return;\n    }\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n    float hitAngleMod = mod(hitAngle, 2.0 * PI);\n    if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) {\n        gl_FragColor = seeThrough(cylinderAngle, yc, v_uv0, rotation, rrotation);\n        return;\n    }\n    point = hitPoint(hitAngle, yc, point, rrotation);\n    if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {\n        gl_FragColor = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n        return;\n    }\n    vec4 color = backside(yc, point);\n    vec4 otherColor;\n    if (yc < 0.0) {\n        float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n        otherColor = vec4(0.0, 0.0, 0.0, shado);\n    } else {\n        otherColor = texture2D(texture, v_uv0);\n    }\n    color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n    vec4 cl = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n    float dist = distanceToEdge(point);\n    gl_FragColor = antiAlias(color, cl, dist);\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform sampler2D targetTex;\nuniform float time;\nconst float MIN_AMOUNT = -0.16;\nconst float MAX_AMOUNT = 1.3;\nconst float PI = 3.141592653589793;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nconst float cylinderRadius = 1.0 / PI / 2.0;\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\nvec4 antiAlias(vec4 color1, vec4 color2, float distance) {\n    distance *= scale;\n    if (distance < 0.0) return color2;\n    if (distance > 2.0) return color1;\n    float dd = pow(1.0 - distance / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\nfloat distanceToEdge(vec3 point) {\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\nvec4 seeThrough(float cylinderAngle, float yc, vec2 p, mat3 rotation, mat3 rrotation) {\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {\n        return texture2D(targetTex, v_uv0);\n    }\n    if (yc > 0.0) return texture2D(texture, p);\n    vec4 color = texture2D(texture, point.xy);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\nvec4 seeThroughWithShadow(float amount, float cylinderAngle, float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation) {\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0) shadow = 0.0;\n    else shadow *= amount;\n    vec4 shadowColor = seeThrough(cylinderAngle, yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\nvec4 backside(float yc, vec3 point) {\n    vec4 color = texture2D(texture, point.xy);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\nvec4 behindSurface(float amount, float cylinderAngle, float yc, vec3 point, mat3 rrotation) {\n    float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\n    shado *= 1.0 - abs(point.x - 0.5);\n    yc = (-cylinderRadius - cylinderRadius - yc);\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n    point = hitPoint(hitAngle, yc, point, rrotation);\n    if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)){\n        shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n    } else\n        shado = 0.0;\n    return vec4(texture2D(targetTex, v_uv0).rgb - shado, 0.0);\n}\nvoid main(void) {\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.12, 0.258, 1\n    );\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.15, -0.5, 1\n    );\n    vec3 point = rotation * vec3(v_uv0, 1.0);\n    float amount = time * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\n    float cylinderAngle = 2.0 * PI * amount;\n    float yc = point.y - amount;\n    if (yc < -cylinderRadius) {\n        gl_FragColor = behindSurface(amount, cylinderAngle, yc, point, rrotation);\n        return;\n    }\n    if (yc > cylinderRadius) {\n        gl_FragColor = texture2D(texture, v_uv0);\n        return;\n    }\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n    float hitAngleMod = mod(hitAngle, 2.0 * PI);\n    if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) {\n        gl_FragColor = seeThrough(cylinderAngle, yc, v_uv0, rotation, rrotation);\n        return;\n    }\n    point = hitPoint(hitAngle, yc, point, rrotation);\n    if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {\n        gl_FragColor = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n        return;\n    }\n    vec4 color = backside(yc, point);\n    vec4 otherColor;\n    if (yc < 0.0) {\n        float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n        otherColor = vec4(0.0, 0.0, 0.0, shado);\n    } else {\n        otherColor = texture2D(texture, v_uv0);\n    }\n    color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n    vec4 cl = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n    float dist = distanceToEdge(point);\n    gl_FragColor = antiAlias(color, cl, dist);\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"],"binding":0},{"name":"properties","members":[{"name":"time","type":13,"count":1}],"defines":[],"binding":1}],"samplers":[{"name":"texture","type":29,"count":1,"defines":["USE_TEXTURE"],"binding":30},{"name":"targetTex","type":29,"count":1,"defines":[],"binding":31}],"record":null,"name":"PageTurn|vs|fs"}]}